## Codebase Patterns
- Use `uv run mypy src/` to typecheck the project
- All functions must have return type annotations for strict mypy
- Database module is at `src/booktok/database.py` with `initialize_database()` function
- Use `uv sync` and `uv add` for dependency management
- Data models are in `src/booktok/models.py` with enums: BookStatus, FileType, Frequency
- All dataclasses have `validate()` method and call it in `__post_init__()`
- Repository pattern: use `DatabaseConnectionManager` from `src/booktok/repository.py`
- Use `with db.transaction()` context manager for write operations (auto commit/rollback)
- SQLite stores booleans as INTEGER (0/1) - convert when reading rows
- ebooklib lacks type stubs - mypy override for "ebooklib.*" is in pyproject.toml
- nltk lacks type stubs - mypy override for "nltk.*" is in pyproject.toml
- Book text extraction is in `src/booktok/book_processor.py` with BookProcessor class
- Use `process_book_safely()` for safe processing with error handling and status updates
- ProcessingResult dataclass provides structured success/error responses with user messages
- Snippet generation in `src/booktok/snippet_generator.py` with SnippetGenerator class
- Use `generate_snippets_safely()` for safe snippet generation with error handling
- Clear mypy cache with `rm -rf .mypy_cache` if pyproject.toml mypy config changes aren't picked up
- Telegram bot interface is in `src/booktok/telegram_bot.py` with TelegramBotInterface class
- Use Application.builder().token(token).build() for python-telegram-bot v20+
- CommandHandler takes (command_name, handler_function) - command name without leading slash
- Delivery scheduling in `src/booktok/delivery_scheduler.py` with DeliveryScheduler class
- User timezone stored in User.timezone field, not in DeliverySchedule
- Use zoneinfo.ZoneInfo for timezone handling; next_delivery_at stored in UTC

---

## 2026-01-10 - US-017
Thread: https://ampcode.com/threads/T-019ba908-1c5e-72e9-8c8c-39c07c7cb2ed
- What was implemented:
  - Added book completion detection in _handle_next (telegram_bot.py)
  - Added book completion detection in _deliver_snippet (delivery_scheduler.py)
  - Completion detected when current_position >= total_snippets
  - is_completed set to True and completed_at timestamp set on completion
  - Congratulatory message sent to user on book completion
  - Updated prd.json to mark US-017 as passes=true
- Files changed:
  - src/booktok/telegram_bot.py - Added completion detection and congratulatory message
  - src/booktok/delivery_scheduler.py - Added completion detection for scheduled delivery
  - prd.json - Updated passes field for US-017
- **Learnings for future iterations:**
  - Use datetime.utcnow() for completed_at timestamp
  - Check completion AFTER incrementing position, not before
  - Completion message format includes book title and total snippets read
  - Scheduled delivery uses send_message_func for congratulatory message
---

## 2026-01-10 - US-002
Thread: https://ampcode.com/threads/T-019ba8e5-1636-73eb-a6be-37164bcce51c
- What was implemented:
  - Created data model dataclasses for User, Book, Snippet, UserProgress, DeliverySchedule
  - Added enums for BookStatus, FileType, and Frequency
  - Implemented validate() method for each dataclass
  - All models use __post_init__ for automatic validation
- Files changed:
  - src/booktok/models.py - New file with all data models
- **Learnings for future iterations:**
  - Use Enum types for constrained choices (BookStatus, FileType, Frequency)
  - ValidationError is a custom exception in models.py
  - delivery_time format is "HH:MM" (24-hour format)
  - Database IDs are Optional[int] since they're set by DB on insert
---

## 2026-01-10 - US-003
Thread: https://ampcode.com/threads/T-019ba8e6-aecb-73e2-9e15-b9ec393af3c5
- What was implemented:
  - Created DatabaseConnectionManager with context manager for transactions
  - Implemented UserRepository with full CRUD + get_by_telegram_id
  - Implemented BookRepository with CRUD + list_by_status
  - Implemented SnippetRepository with CRUD + bulk create, get_by_book_and_position
  - Implemented UserProgressRepository with CRUD + get_by_user_and_book
  - Implemented DeliveryScheduleRepository with CRUD + list_pending_deliveries
  - Created MigrationManager for database version tracking
- Files changed:
  - src/booktok/repository.py - New file with all repositories
- **Learnings for future iterations:**
  - All repositories use DatabaseConnectionManager for shared connection handling
  - Use `with db.transaction()` for write operations (auto commit/rollback)
  - SQLite stores booleans as INTEGER (0/1) - convert in row_to_model methods
  - datetime values stored as ISO format strings, parse with fromisoformat()
  - MigrationManager tracks applied migrations in `migrations` table
---

## 2026-01-10 - US-004
Thread: https://ampcode.com/threads/T-019ba8e9-8dfb-7368-93a9-69385ec26836
- What was implemented:
  - Created BookProcessor class with PDF text extraction using PyPDF2
  - Implemented multi-page PDF handling with page-by-page extraction
  - Text cleaning/normalization (whitespace, line breaks, hyphenation fix)
  - Custom exceptions: BookProcessingError, InvalidFileError, UnsupportedFileTypeError
  - Updated __init__.py to export new classes
- Files changed:
  - src/booktok/book_processor.py - New file with PDF extraction logic
  - src/booktok/__init__.py - Added exports for book processor classes
- **Learnings for future iterations:**
  - PyPDF2 uses PdfReader class (not PdfFileReader in v3+)
  - PdfReadError is in PyPDF2.errors module
  - Image-based PDFs won't yield text - need to detect and report this
  - Hyphenation across lines is handled by regex: r"(\w)-\s*\n\s*(\w)" -> r"\1\2"
---

## 2026-01-10 - US-005
Thread: https://ampcode.com/threads/T-019ba8eb-4b56-726a-922f-d9b69a7d1edc
- What was implemented:
  - Extended BookProcessor with EPUB text extraction using ebooklib
  - Added BeautifulSoup for HTML parsing of EPUB content
  - Strips script/style tags, extracts text with proper separator
  - Error handling for invalid/corrupted EPUBs (catches EpubException)
  - Uses same _clean_and_normalize_text method as PDF for consistency
- Files changed:
  - src/booktok/book_processor.py - Added _extract_epub_text method, updated imports
  - pyproject.toml - Added beautifulsoup4 dependency, mypy override for ebooklib
  - uv.lock - Updated with new dependency
- **Learnings for future iterations:**
  - ebooklib lacks type stubs - need mypy override in pyproject.toml
  - Use `epub.read_epub(path, options={"ignore_ncx": True})` to avoid NCX parsing issues
  - EPUB items of type ITEM_DOCUMENT contain the readable content
  - BeautifulSoup `get_text(separator="\n")` preserves paragraph structure
---

## 2026-01-10 - US-006
Thread: https://ampcode.com/threads/T-019ba8ee-9d53-754d-b58d-096f8e424a74
- What was implemented:
  - Added file validation before processing (size limits, magic byte checks)
  - Created ProcessingResult dataclass for structured error responses
  - Added validate_file() method with comprehensive checks
  - Implemented process_book_safely() method with full error handling
  - Added _mark_as_failed() to set BookStatus.FAILED on errors
  - All errors logged with details (exc_info=True)
  - User-friendly error messages returned via ProcessingResult
- Files changed:
  - src/booktok/book_processor.py - Added validation, ProcessingResult, safe processing
  - src/booktok/__init__.py - Exported ProcessingResult
- **Learnings for future iterations:**
  - PDF files start with b"%PDF" magic bytes
  - EPUB files are ZIP archives (start with b"PK\x03\x04")
  - Use ProcessingResult for safe processing with user-friendly error messages
  - process_book_safely() handles all exceptions and updates book status
  - File size limits: MIN=100 bytes, MAX=100MB
---

## 2026-01-10 - US-007
Thread: https://ampcode.com/threads/T-019ba8f1-b1ae-7100-ac54-25e5cf477125
- What was implemented:
  - Created SnippetGenerator class with NLTK integration for text processing
  - Implemented paragraph boundary detection using double-newline splitting
  - Snippets extracted as 1-2 paragraph chunks based on target length (800 chars)
  - Sequential position markers (0-indexed) assigned to each snippet
  - Snippet objects created with book_id and position metadata
  - Added generate_snippets_safely() with SnippetGenerationResult for error handling
  - Added NLTK punkt_tab tokenizer auto-download for sentence detection
- Files changed:
  - src/booktok/snippet_generator.py - New file with SnippetGenerator class
  - src/booktok/__init__.py - Exported SnippetGenerator, SnippetGenerationError, SnippetGenerationResult
  - pyproject.toml - Added mypy override for nltk module
- **Learnings for future iterations:**
  - nltk lacks type stubs - need mypy override in pyproject.toml
  - Use `nltk.data.find("tokenizers/punkt_tab")` to check if data exists before download
  - Paragraph detection: split on `\n\s*\n` regex, filter paragraphs < 20 chars
  - Snippet constants: MIN_LENGTH=100, MAX_LENGTH=3500, TARGET_LENGTH=800
  - Clear mypy cache if pyproject.toml config changes aren't picked up
- Snippet formatting is in `src/booktok/snippet_formatter.py` with SnippetFormatter class
- Telegram message limit is 4096 chars; use HEADER_RESERVE=200 for safe content
- Use `validate_message_length()` utility function to check message lengths
---

## 2026-01-10 - US-008
Thread: https://ampcode.com/threads/T-019ba8f5-d61e-764e-addf-06966835de02
- What was implemented:
  - Created SnippetFormatter class for Telegram message formatting
  - Implemented FormattedMessage and FormattedSnippet dataclasses
  - Message length validation against Telegram 4096 char limit
  - Long snippet splitting across multiple messages with continuation markers
  - Header with book title, author (with emoji), and progress indicator
  - Markdown escaping for special characters
  - Paragraph break formatting for clean display
- Files changed:
  - src/booktok/snippet_formatter.py - New file with formatter logic
  - src/booktok/__init__.py - Added exports for formatter classes
- **Learnings for future iterations:**
  - TELEGRAM_MAX_MESSAGE_LENGTH = 4096 chars per message
  - Reserve 200 chars for header when calculating safe content length
  - Split at paragraph boundaries first, then sentence boundaries, then word
  - Use emojis: ðŸ“š for book title, âœï¸ for author, ðŸ“– for progress
  - Escape Markdown special chars: _ * [ ] ( ) ~ ` > # + - = | { } . !
---

## 2026-01-10 - US-009
Thread: https://ampcode.com/threads/T-019ba8f8-a1cb-717e-8dbb-cd3aba72b0b0
- What was implemented:
  - Created TelegramBotInterface class with command routing using python-telegram-bot
  - Implemented /start command with welcome message and user profile creation
  - Implemented /help command listing available commands
  - User profile created/updated on first interaction with telegram_id, username, names
  - Updated __init__.py to export TelegramBotInterface
- Files changed:
  - src/booktok/telegram_bot.py - New file with bot interface and command handlers
  - src/booktok/__init__.py - Added exports for TelegramBotInterface
- **Learnings for future iterations:**
  - Use Application.builder().token(token).build() for python-telegram-bot v20+
  - CommandHandler takes (command_name, handler_function) - no leading slash
  - Update objects have effective_user (TelegramUser) and message (Message)
  - Use parse_mode="Markdown" for formatted messages with *bold* etc.
  - For polling: initialize() -> start() -> updater.start_polling()
---

## 2026-01-10 - US-010
Thread: https://ampcode.com/threads/T-019ba8fb-877b-75d5-96b3-d0dc5d700c30
- What was implemented:
  - Added MessageHandler for unrecognized commands using filters.COMMAND
  - Created UNRECOGNIZED_COMMAND_MESSAGE with list of valid commands
  - Implemented _handle_unrecognized_command() for invalid commands
  - Implemented _handle_text_message() for plain text (non-command) messages
  - Added _get_suggestion_message() with common mistake detection (typos like "helps", "nexts")
  - Suggestions provided for common words: begin->start, continue->next, menu->help, etc.
- Files changed:
  - src/booktok/telegram_bot.py - Added MessageHandler, filters imports; new handler methods
- **Learnings for future iterations:**
  - Use `filters.COMMAND & ~filters.Regex(r"^/(start|help|next)")` to catch unrecognized commands
  - MessageHandler with `filters.TEXT & ~filters.COMMAND` catches plain text messages
  - Telegram filter operators: `&` (and), `|` (or), `~` (not)
---

## 2026-01-10 - US-011
Thread: https://ampcode.com/threads/T-019ba8fd-06ef-73d7-a53f-36b19b45a529
- What was implemented:
  - Added /next command handler to TelegramBotInterface
  - Fetches user's active book progress and delivers next snippet
  - Uses SnippetFormatter to include book title, author, and progress indicator
  - Multi-message support for long snippets (respects Telegram 4096 char limit)
  - Added BookRepository, SnippetRepository, UserProgressRepository to TelegramBotInterface
- Files changed:
  - src/booktok/telegram_bot.py - Added /next command handler with snippet delivery
- **Learnings for future iterations:**
  - Use `progress_repo.list_by_user()` and filter for `is_completed=False` to find active books
  - SnippetFormatter handles all message formatting including headers and continuation markers
  - current_position in UserProgress is 0-indexed, but display is 1-indexed
  - snippet_repo.get_by_book_and_position() retrieves snippet by position, not ID
---

## 2026-01-10 - US-012
Thread: https://ampcode.com/threads/T-019ba8fe-dcc9-7412-909a-8572e0046bc7
- What was implemented:
  - Created DeliveryScheduler class for managing user delivery schedules
  - Implemented set_schedule() method to set/update delivery time and frequency
  - Schedule stored in database via DeliveryScheduleRepository
  - Timezone preference stored for each user in User model
  - Created ScheduleInfo dataclass with format_for_display() for user-facing output
  - Implemented get_schedule_info() and format_schedules_for_display() for retrieval
  - Added update_user_timezone() to update user timezone preference
  - Next delivery calculation based on user timezone
  - Exception classes: SchedulerError, InvalidTimezoneError, InvalidScheduleError, UserNotFoundError, BookNotFoundError
- Files changed:
  - src/booktok/delivery_scheduler.py - New file with DeliveryScheduler class
  - src/booktok/__init__.py - Added exports for scheduler classes
- **Learnings for future iterations:**
  - User timezone is stored in User model, not DeliverySchedule
  - Use zoneinfo.ZoneInfo for timezone handling (Python 3.9+)
  - DeliveryScheduleRepository already exists in repository.py with full CRUD
  - Next delivery times are stored in UTC, converted to local for display
  - Frequency enum: DAILY, TWICE_DAILY, WEEKLY from models.py
  - AutomatedDeliveryRunner in delivery_scheduler.py handles background scheduled delivery
  - Use `SendMessageFunc = Callable[[int, str], asyncio.Future[bool]]` type for message sending callback
  - `list_pending_deliveries(before: datetime)` retrieves schedules ready for delivery

  ---

  ## 2026-01-10 - US-013
  Thread: https://ampcode.com/threads/T-019ba901-4518-75ee-a03b-a22a71ece181
  - What was implemented:
    - Created AutomatedDeliveryRunner class with background async task loop
    - Background task checks for pending deliveries periodically (configurable interval)
    - Scheduled delivery executes when next_delivery_at <= now (UTC)
    - User timezone respected via stored user.timezone for next delivery calculation
    - Message sent via injectable send_message_func callback for Telegram API
    - System continues running with asyncio task, start()/stop() methods for lifecycle
    - Added DeliveryResult dataclass for structured delivery attempt results
    - run_once() method for testing/manual triggering
  - Files changed:
    - src/booktok/delivery_scheduler.py - Added AutomatedDeliveryRunner, DeliveryResult
    - src/booktok/__init__.py - Exported new classes
  - **Learnings for future iterations:**
    - Use SendMessageFunc type alias for Telegram message callbacks
    - AutomatedDeliveryRunner.start() creates asyncio.Task for background loop
    - _update_schedule_after_delivery() sets last_delivered_at and calculates next_delivery_at
    - For TWICE_DAILY frequency, adds 12 hours (not next day)
  ---

## 2026-01-10 - US-014
Thread: https://ampcode.com/threads/T-019ba904-0e5b-726d-80a4-4d8cb590f979
- What was implemented:
  - Added pause_schedule(), resume_schedule(), pause_all_schedules(), resume_all_schedules() to DeliveryScheduler
  - Added /pause command handler to TelegramBotInterface - pauses all user schedules
  - Added /resume command handler to TelegramBotInterface - resumes all user schedules with recalculated next delivery
  - Updated HELP_MESSAGE, UNRECOGNIZED_COMMAND_MESSAGE, and VALID_COMMANDS
  - Added common mistake suggestions for pause/resume (stop, halt, unpause, restart)
  - /next command already works regardless of schedule (does not check is_paused)
- Files changed:
  - src/booktok/delivery_scheduler.py - Added pause/resume methods
  - src/booktok/telegram_bot.py - Added /pause and /resume commands
- **Learnings for future iterations:**
  - is_paused field is already in DeliverySchedule model and persisted in database
  - list_pending_deliveries() already filters out paused schedules (WHERE is_paused = 0)
  - When resuming, recalculate next_delivery_at based on user timezone
  - /next command bypasses the schedule entirely - always delivers from current position
---

## 2026-01-10 - US-015
Thread: https://ampcode.com/threads/T-019ba906-15d3-72e5-a7c9-06f0b3ae2f5c
- What was implemented:
  - Verified progress tracking implementation is already complete
  - Progress updated in _handle_next (telegram_bot.py) and _deliver_snippet (delivery_scheduler.py)
  - UserProgress model stores user_id, book_id, current_position with proper validation
  - UserProgressRepository provides get_by_user_and_book() for retrieval
  - Progress persisted via progress_repo.update() after every snippet delivery
  - Updated PRD to mark US-015 as passes=true
- Files changed:
  - prd.json - Updated passes field for US-015
- **Learnings for future iterations:**
  - Progress tracking is implemented in two places: manual /next command and scheduled delivery
  - Both use the same UserProgress model and repository for consistency
  - current_position is 0-indexed in database, displayed as 1-indexed to users
---

## 2026-01-10 - US-016
Thread: https://ampcode.com/threads/T-019ba907-1a5f-72c7-894b-26c25f7bcbef
- What was implemented:
  - Added initialize_progress() method to UserProgressRepository
  - Method checks if progress exists, creates new record with current_position=0, is_completed=False if not
  - Added start_book() method to TelegramBotInterface for initializing user progress on a book
  - Added UserProgress import to telegram_bot.py
  - Updated prd.json to mark US-016 as passes=true
- Files changed:
  - src/booktok/repository.py - Added initialize_progress() method
  - src/booktok/telegram_bot.py - Added start_book() method and UserProgress import
  - prd.json - Updated passes field for US-016
- **Learnings for future iterations:**
  - Use initialize_progress() pattern for creating records only if they don't exist
  - Import UserProgress model when using progress types in telegram_bot.py
  - start_book() can be called when a user wants to begin reading a specific book
---
